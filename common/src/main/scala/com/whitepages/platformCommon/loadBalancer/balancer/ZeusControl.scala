package com.whitepages.platformCommon.loadBalancer.balancer

import java.security.cert.X509Certificate
import javax.net.ssl._

import akka.actor.ActorSystem
import akka.io.IO
import akka.pattern.ask
import akka.util.Timeout
import com.persist.Exceptions.JsonParseException
import com.persist.JsonMapper._
import com.persist.JsonOps._
import com.typesafe.config.Config
import com.whitepages.platformCommon.credentials.CredentialProvider
import com.whitepages.platformCommon.loadBalancer.LoadBalancerConfig
import org.joda.time.{DateTime, DateTimeZone}
import spray.can.Http
import spray.can.Http.HostConnectorSetup
import spray.client.pipelining._
import spray.http._

import scala.concurrent.Future
import scala.concurrent.duration._
import scala.io.Source

/*
Zeus configuration elements:

Configuration: /api/tm/3.0/config

Active configuration: /api/tm/3.0/config/active
 children ->
  action_programs
  actions
  appliance
  application_firewall
  aptimizer
  bandwidth
  cloud_api_credentials
  custom
  event_types
  extra_files
  glb_services
  global_settings
  kerberos
  license_keys
  locations
  monitor_scripts
  monitors
  persistence
  pools
  protection
  rate
  rule_authenticators
  rules
  security
  service_level_monitors
  ssl
  traffic_ip_groups
  traffic_managers
  user_authenticators
  user_groups
  virtual_servers
 */

object Node {
  def zNodeToNode(zNode: ZeusDomainModel.Node): Node =
    Node( host = zNode.node.takeWhile(_ != ':')
      , port = zNode.port.getOrElse(-1)
      , isEnabledOpt = Some(zNode.isActive)
    )
}

sealed case class Node(host: String, port: Int, isEnabledOpt: Option[Boolean]) {
  override def toString: String = s"$host:$port"

  def ~=(other: Node): Boolean =
    this.host == other.host &&
      this.port == other.port

  def isEnabled: Boolean = isEnabledOpt.isDefined && isEnabledOpt.get
}

object ZeusControl extends LoadBalancerConfig {
  val poolsResourceName = "pools"
  val virtualServerResourceName = "virtual_servers"
  val trafficIpGroupsResourceName = "traffic_ip_groups"

  private def readJsonResource(resourceName: String): Option[Json] = {
    import com.persist.Exceptions.JsonParseException

    Option(getClass.getResource(resourceName)) match {
      case Some(url) => scala.util.control.Exception.catching(classOf[JsonParseException]).opt {
        Json(Source.fromURL(url).getLines().mkString)
      }
      case None => None
    }
  }

  private def now: String = DateTime.now(DateTimeZone.UTC).toString

  def extractConfig(config: Config, balancerScope: String, credentialProvider: CredentialProvider): ZeusConfig = {

    val controlAddress = config.getString(controlAddressKey)
    val controlPort = config.getInt(controlPortKey)
    val (controlUser, controlPassword) =
      if (config.hasPath(controlUserKey) && config.hasPath(controlPasswordKey))
        (config.getString(controlUserKey), config.getString(controlPasswordKey))
      else {
        val credentials = credentialProvider.lbCredentials(Some(balancerScope))
        (credentials.identity, credentials.secret)
      }
    ZeusConfig(controlAddress, controlPort, controlUser, controlPassword, apiVersion = "3.2")
  }
}

case class ZeusConfig(controlAddress: String
                      , controlPort: Int
                      , controlUser: String
                      , controlPassword: String
                      , apiVersion: String="3.2" // TODO: pull from config
                      )

trait ZeusControl {
  protected implicit def system: ActorSystem
  import scala.concurrent.ExecutionContext.Implicits.global // TODO: use different execution context

  def zeusConfig: ZeusConfig

  /*
  Builders
   */
  def newVipBuilder(name: String): VipBuilder = {
    val vipTemplate: Json =
      ZeusControl.readJsonResource("/zeus-new-vip.json") match {
        case Some(t) => t
        case None => throw LoadBalancerProviderException("Missing VIP template")
      }
    VipBuilder(this, name, jput(vipTemplate, "properties", "basic", "note")(s"autogenerated on ${ZeusControl.now}"))
  }

  def newPoolBuilder(name: String): PoolBuilder = {
    val poolTemplate: Json =
      ZeusControl.readJsonResource("/zeus-new-pool.json") match {
        case Some(t) => t
        case None => throw LoadBalancerProviderException("Missing pool template")
      }
    PoolBuilder(this, name, jput(poolTemplate, "properties", "basic", "note")(s"autogenerated on ${ZeusControl.now}"))
  }

  def newTrafficIpGroupBuilder(name: String): TrafficIpGroupBuilder = {
    val trafficIpBuilderTemplate =
      ZeusControl.readJsonResource("/zeus-new-traffic-ip-group.json") match {
        case Some(t) => t
        case None => throw LoadBalancerProviderException("Missing traffic IP group template")
      }
    TrafficIpGroupBuilder(this, name, jput(trafficIpBuilderTemplate, "properties", "basic", "note")(s"autogenerated on ${ZeusControl.now}"))
  }

  /*
  spray.io custom SSLContext to bypass security checks (when testing, etc.); see http://spray.io/documentation/1.2.2/spray-can/http-server/#ssl-support
  Bringing it into scope removes errors like:
  PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
   */
  private implicit val trustfulSslContext: SSLContext = {

    object NoCheckX509TrustManager extends X509TrustManager {
      override def checkClientTrusted(chain: Array[X509Certificate], authType: String) = ()
      override def checkServerTrusted(chain: Array[X509Certificate], authType: String) = ()
      override def getAcceptedIssuers = Array[X509Certificate]()
    }

    val context = SSLContext.getInstance("TLS")
    context.init(Array[KeyManager](), Array(NoCheckX509TrustManager), null /* Java API */)
    context
  }

  private [this] def buildControlUri(controlEndpoint: String, controlPort: Int, resource: String, resourceId: String): Uri =  {
    val authority = Uri.Authority(Uri.Host(controlEndpoint), controlPort)
    val path = Uri.Path(Seq(s"/api/tm/${zeusConfig.apiVersion}/config/active", resource, resourceId).filter(_.nonEmpty).mkString("/"))
    Uri(scheme = "https", authority = authority, path = path)
  }

  private [this] implicit val askTimeout = Timeout(25.seconds) // TODO: factor out

  private [this] def buildPipeline(uri: Uri): Future[SendReceive] = {
    val pipeline =
      for (Http.HostConnectorInfo(hostConnector, _) <-
           IO(Http) ? HostConnectorSetup(host = uri.authority.host.address, port = uri.authority.port, sslEncryption = true)
    ) yield
      (
        addHeader("Accept", "*/*")
          ~> addCredentials(BasicHttpCredentials(zeusConfig.controlUser, zeusConfig.controlPassword))
          ~> sendReceive(hostConnector)
        )
    pipeline
  }

  private [balancer] def getResource(resource: String, resourceId: String): Future[Json] = {
    val controlUri = buildControlUri(zeusConfig.controlAddress, zeusConfig.controlPort, resource, resourceId)
    val pipeline = buildPipeline(controlUri)
    val getRequest = HttpRequest(method = HttpMethods.GET, uri = controlUri.toRelative, entity = HttpEntity(ContentTypes.`application/json`, ""))
    pipeline
      .flatMap(_(getRequest))
      .map(response =>
        if (response.status.isSuccess)
          scala.util.control.Exception.catching(classOf[JsonParseException]).withApply {
            case jpe: JsonParseException => throw LoadBalancerProviderException(s"Exception thrown while parsing JSON GET response: ${jpe.msg}")
          } {
            Json(response.entity.asString)
          }
        else throw LoadBalancerProviderException(s"Received response with failure code ${response.status.value}; reason: ${response.status.reason}")
      )
  }

  /*
  According to the docs:
   "Partial updates to configuration resources can be performed by only including the
    properties that need to be altered. Other properties are left unchanged."

   "The REST service returns a "200 OK" response for a correctly updated configuration set,
    or "201 Created" for establishing a new configuration object of a particular resource
    type. In these cases, the fullresourceisreturnedastheresponsebody. Theonlyexceptionto
    thisruleiswhenupdatingaraw file, which instead returns a "204 No Content" empty-body
    response."

   */
  private[balancer] def putResource(resource: String, resourceId: String, config: Json, expectedCodeOpt: Option[Int] = None): Future[Json] = {
    val controlUri = buildControlUri(zeusConfig.controlAddress, zeusConfig.controlPort, resource, resourceId)
    val pipeline = buildPipeline(controlUri)
    val data = HttpData(Compact(config), charset = HttpCharsets.`UTF-8`)
    val putRequest =
      HttpRequest(method = HttpMethods.PUT
        , uri = controlUri.toRelative
        , entity = HttpEntity(MediaTypes.`application/json`, data)
      )
    pipeline
      .flatMap(_(putRequest))
      .map(response => // TODO: filter and project response
      (response.status.isSuccess, expectedCodeOpt) match {
        case (true, Some(code)) if response.status.intValue == code =>
          scala.util.control.Exception.catching(classOf[Throwable]).withApply {
            case jpe: JsonParseException => throw LoadBalancerProviderException(s"Exception thrown while parsing JSON PUT response: ${jpe.msg}")
          } {
            Json(response.entity.asString)
          }
        case (true, None) =>
          scala.util.control.Exception.catching(classOf[Throwable]).withApply {
            case jpe: JsonParseException => throw LoadBalancerProviderException(s"Exception thrown while parsing JSON PUT response: ${jpe.msg}")
          }  {
            Json(response.entity.asString)
          }
        case (false, _) =>
          throw LoadBalancerProviderException(s"Received response with failure code ${response.status.value}; reason: ${response.status.reason}")
      })
  }

  private def deleteResource(resource: String, resourceId: String) = {
    val controlUri = buildControlUri(zeusConfig.controlAddress, zeusConfig.controlPort, resource, resourceId)
    val pipeline = buildPipeline(controlUri)
    val deleteRequest = HttpRequest(method = HttpMethods.DELETE, uri = controlUri.toRelative)
    pipeline
      .flatMap(_(deleteRequest))
      .map(response =>
      if (response.status.intValue == 204) (): Unit
      else                                 throw new IllegalArgumentException(s"Unexpected status code ${response.status.intValue} from DELETE request")
      )
  }

  def getPoolHosts(pool: String): Future[Seq[ZeusDomainModel.Node]] = {
    getResource(ZeusControl.poolsResourceName, pool)
      .map(json => jgetArray(json, "properties", "basic", "nodes_table").map(each => ToObject[ZeusDomainModel.Node](each)))
  }

  type ZeusNodePredicate = ZeusDomainModel.Node => ZeusDomainModel.Node

  /*
  Gets all the nodes in a pool, applies the transformation to the nodes matching the query, and return the unmodified + modified nodes
   */
   def selectNodes(pool: String, queryNodes: Seq[Node], nodeTransformation: ZeusNodePredicate): Future[Seq[ZeusDomainModel.Node]] = {

    def findNode(nodes: Seq[ZeusDomainModel.Node], n: Node): Option[ZeusDomainModel.Node] = {
      nodes.find(zn => zn.node == n.toString)
    }

    getPoolHosts(pool).map(zNodes => 
      if (zNodes.nonEmpty) {
        val (targetNodes, unchangedNodes) = zNodes.partition(zn => queryNodes.exists(_.toString == zn.node))
        val updatedNodes = targetNodes.map(nodeTransformation)
        unchangedNodes ++ updatedNodes
       } else {
        Seq.empty[ZeusDomainModel.Node] 
      }
    )
  }

  private [balancer] def buildNodesTableJson(nodes: Seq[ZeusDomainModel.Node]): JsonObject =
    JsonObject("properties" ->
      JsonObject("basic" ->
        JsonObject("nodes_table" ->
          (emptyJsonArray ++ nodes.map(ToJson[ZeusDomainModel.Node])))))


  private [balancer] def modifyMatchingNodes(pool: String, queryNodes: Seq[Node], selector: ZeusNodePredicate): Future[Json] =
    selectNodes(pool, queryNodes, selector)
      .flatMap(zNodes => {
        val json = buildNodesTableJson(zNodes)
        putResource(ZeusControl.poolsResourceName, pool, json, expectedCodeOpt = None)
      }
    )


  /*
  Traffic IP group API
   */

  def createTrafficIpGroup(ipGroupName: String): TrafficIpGroupBuilder = newTrafficIpGroupBuilder(ipGroupName)

  def doCreateTrafficIpGroup(name: String, json: Json): Future[Json] = {
    putResource(ZeusControl.trafficIpGroupsResourceName, name, json, expectedCodeOpt = None)
  }

  def deleteTrafficIpGroup(ipGroupName: String): Future[Unit] = deleteResource(ZeusControl.trafficIpGroupsResourceName, ipGroupName)

  /*
  Vip-level API
   */
  def createVip(vipName: String): VipBuilder = newVipBuilder(vipName)

  def doCreateVip(vipName: String, json: Json): Future[Json] = {
    putResource(ZeusControl.virtualServerResourceName, vipName, json, expectedCodeOpt = None)
  }

  def deleteVip(vipName: String): Future[Unit] = deleteResource(ZeusControl.virtualServerResourceName, vipName)

  def setVipState(vipName: String, isEnabled: Boolean): Future[Json] = {
    /*
        def toggleStateIfNeeded(json: Json) =
          if (jgetBoolean(json, "enabled") != isEnabled) {
            val updatedJson =
              JsonObject("properties" ->
                JsonObject("basic" ->
                  JsonObject("enabled" -> isEnabled)))
            putResource("virtual_servers", vipName, updatedJson, expectNoContent = false)
          }
          else
            Future.successful[Option[Json]](None)

        getResource("virtual_servers", vipName).map {
          case Some(json) => jgetObject(json, "properties", "basic")
          case None => None
        }.flatMap(toggleStateIfNeeded)
        */
    val updatedJson =
      JsonObject("properties" ->
        JsonObject("basic" ->
          JsonObject("enabled" -> isEnabled)))
    putResource(ZeusControl.virtualServerResourceName, vipName, updatedJson, expectedCodeOpt = None)
  }

  /*
  Health check
   */
  def isHealthy(): Future[Boolean] =
    getResource("", "")
      .map(json => true)
      .recover { case t: Throwable => false}

  /*
  Pool-level API
   */
  def query(pool: String): Future[Seq[Node]] =
    getPoolHosts(pool)
      .map(zNodes => zNodes.map(Node.zNodeToNode))

  private def jsonNodeTableToHosts(json: Json): Seq[Node] =
   jgetArray(json, "properties", "basic", "nodes_table")
        .map(each => ToObject[ZeusDomainModel.Node](each))
        .map(Node.zNodeToNode)

  def addNode(pool: String, node: Node): Future[Seq[Node]] =
    getPoolHosts(pool).map { others =>
      others :+ ZeusDomainModel.Node(node = node.toString)
    }.flatMap(updatedNodes => {
      val json = buildNodesTableJson(updatedNodes)
      putResource(ZeusControl.poolsResourceName, pool, json, expectedCodeOpt = None)
    }).map(jsonNodeTableToHosts)

  def removeNode(pool: String, node: Node): Future[Seq[Node]] =
    getPoolHosts(pool).map { others =>
      others.filter(zNode => zNode.node != node.toString)
    }.flatMap(updatedNodes => {
      val json = buildNodesTableJson(updatedNodes)
      putResource(ZeusControl.poolsResourceName, pool, json, expectedCodeOpt = None)
    }).map(jsonNodeTableToHosts)

  def createPool(poolName: String): PoolBuilder = newPoolBuilder(poolName)

  def doCreatePool(poolName: String, json: Json): Future[Json] = {
    putResource(ZeusControl.poolsResourceName, poolName, json, expectedCodeOpt = None)
  }

  def deletePool(name: String): Future[Unit] = deleteResource(ZeusControl.poolsResourceName, name)

  /*
   Node-level API
   */
  def enableNodes(pool: String, nodes: Seq[Node]): Future[Json] = {

    def enableDisabledNode(zn: ZeusDomainModel.Node): ZeusDomainModel.Node =
      if (zn.isDisabled) zn.makeActive() else zn

    modifyMatchingNodes(pool, nodes, enableDisabledNode)
  }

  def disableNodes(pool: String, nodes: Seq[Node]): Future[Json] = {

    def disableEnabledNode(zn: ZeusDomainModel.Node): ZeusDomainModel.Node =
      if (zn.isActive) zn.makeDisabled() else zn

    modifyMatchingNodes(pool, nodes, disableEnabledNode)
  }

}
